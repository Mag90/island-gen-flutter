// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'package:island_gen_flutter/models/layer.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LayerNoiseParams {
  LayerNoiseType get type => throw _privateConstructorUsedError;
  double get scale => throw _privateConstructorUsedError;
  double get frequency => throw _privateConstructorUsedError;
  int get octaves => throw _privateConstructorUsedError;
  double get persistence => throw _privateConstructorUsedError;
  double get lacunarity => throw _privateConstructorUsedError;
  double get offsetX => throw _privateConstructorUsedError;
  double get offsetY => throw _privateConstructorUsedError;
  double get rotation => throw _privateConstructorUsedError;
  bool get invert => throw _privateConstructorUsedError;
  double get clampMin => throw _privateConstructorUsedError;
  double get clampMax => throw _privateConstructorUsedError;
  int get seed => throw _privateConstructorUsedError;

  /// Create a copy of LayerNoiseParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LayerNoiseParamsCopyWith<LayerNoiseParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LayerNoiseParamsCopyWith<$Res> {
  factory $LayerNoiseParamsCopyWith(
          LayerNoiseParams value, $Res Function(LayerNoiseParams) then) =
      _$LayerNoiseParamsCopyWithImpl<$Res, LayerNoiseParams>;
  @useResult
  $Res call(
      {LayerNoiseType type,
      double scale,
      double frequency,
      int octaves,
      double persistence,
      double lacunarity,
      double offsetX,
      double offsetY,
      double rotation,
      bool invert,
      double clampMin,
      double clampMax,
      int seed});
}

/// @nodoc
class _$LayerNoiseParamsCopyWithImpl<$Res, $Val extends LayerNoiseParams>
    implements $LayerNoiseParamsCopyWith<$Res> {
  _$LayerNoiseParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LayerNoiseParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? scale = null,
    Object? frequency = null,
    Object? octaves = null,
    Object? persistence = null,
    Object? lacunarity = null,
    Object? offsetX = null,
    Object? offsetY = null,
    Object? rotation = null,
    Object? invert = null,
    Object? clampMin = null,
    Object? clampMax = null,
    Object? seed = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as LayerNoiseType,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      frequency: null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as double,
      octaves: null == octaves
          ? _value.octaves
          : octaves // ignore: cast_nullable_to_non_nullable
              as int,
      persistence: null == persistence
          ? _value.persistence
          : persistence // ignore: cast_nullable_to_non_nullable
              as double,
      lacunarity: null == lacunarity
          ? _value.lacunarity
          : lacunarity // ignore: cast_nullable_to_non_nullable
              as double,
      offsetX: null == offsetX
          ? _value.offsetX
          : offsetX // ignore: cast_nullable_to_non_nullable
              as double,
      offsetY: null == offsetY
          ? _value.offsetY
          : offsetY // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      invert: null == invert
          ? _value.invert
          : invert // ignore: cast_nullable_to_non_nullable
              as bool,
      clampMin: null == clampMin
          ? _value.clampMin
          : clampMin // ignore: cast_nullable_to_non_nullable
              as double,
      clampMax: null == clampMax
          ? _value.clampMax
          : clampMax // ignore: cast_nullable_to_non_nullable
              as double,
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LayerNoiseParamsImplCopyWith<$Res>
    implements $LayerNoiseParamsCopyWith<$Res> {
  factory _$$LayerNoiseParamsImplCopyWith(_$LayerNoiseParamsImpl value,
          $Res Function(_$LayerNoiseParamsImpl) then) =
      __$$LayerNoiseParamsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {LayerNoiseType type,
      double scale,
      double frequency,
      int octaves,
      double persistence,
      double lacunarity,
      double offsetX,
      double offsetY,
      double rotation,
      bool invert,
      double clampMin,
      double clampMax,
      int seed});
}

/// @nodoc
class __$$LayerNoiseParamsImplCopyWithImpl<$Res>
    extends _$LayerNoiseParamsCopyWithImpl<$Res, _$LayerNoiseParamsImpl>
    implements _$$LayerNoiseParamsImplCopyWith<$Res> {
  __$$LayerNoiseParamsImplCopyWithImpl(_$LayerNoiseParamsImpl _value,
      $Res Function(_$LayerNoiseParamsImpl) _then)
      : super(_value, _then);

  /// Create a copy of LayerNoiseParams
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? scale = null,
    Object? frequency = null,
    Object? octaves = null,
    Object? persistence = null,
    Object? lacunarity = null,
    Object? offsetX = null,
    Object? offsetY = null,
    Object? rotation = null,
    Object? invert = null,
    Object? clampMin = null,
    Object? clampMax = null,
    Object? seed = null,
  }) {
    return _then(_$LayerNoiseParamsImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as LayerNoiseType,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      frequency: null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as double,
      octaves: null == octaves
          ? _value.octaves
          : octaves // ignore: cast_nullable_to_non_nullable
              as int,
      persistence: null == persistence
          ? _value.persistence
          : persistence // ignore: cast_nullable_to_non_nullable
              as double,
      lacunarity: null == lacunarity
          ? _value.lacunarity
          : lacunarity // ignore: cast_nullable_to_non_nullable
              as double,
      offsetX: null == offsetX
          ? _value.offsetX
          : offsetX // ignore: cast_nullable_to_non_nullable
              as double,
      offsetY: null == offsetY
          ? _value.offsetY
          : offsetY // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      invert: null == invert
          ? _value.invert
          : invert // ignore: cast_nullable_to_non_nullable
              as bool,
      clampMin: null == clampMin
          ? _value.clampMin
          : clampMin // ignore: cast_nullable_to_non_nullable
              as double,
      clampMax: null == clampMax
          ? _value.clampMax
          : clampMax // ignore: cast_nullable_to_non_nullable
              as double,
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LayerNoiseParamsImpl implements _LayerNoiseParams {
  const _$LayerNoiseParamsImpl(
      {this.type = LayerNoiseType.perlin,
      this.scale = 1.0,
      this.frequency = 0.01,
      this.octaves = 4,
      this.persistence = 0.5,
      this.lacunarity = 2.0,
      this.offsetX = 0.0,
      this.offsetY = 0.0,
      this.rotation = 0.0,
      this.invert = false,
      this.clampMin = 0.0,
      this.clampMax = 1.0,
      this.seed = 0});

  @override
  @JsonKey()
  final LayerNoiseType type;
  @override
  @JsonKey()
  final double scale;
  @override
  @JsonKey()
  final double frequency;
  @override
  @JsonKey()
  final int octaves;
  @override
  @JsonKey()
  final double persistence;
  @override
  @JsonKey()
  final double lacunarity;
  @override
  @JsonKey()
  final double offsetX;
  @override
  @JsonKey()
  final double offsetY;
  @override
  @JsonKey()
  final double rotation;
  @override
  @JsonKey()
  final bool invert;
  @override
  @JsonKey()
  final double clampMin;
  @override
  @JsonKey()
  final double clampMax;
  @override
  @JsonKey()
  final int seed;

  @override
  String toString() {
    return 'LayerNoiseParams(type: $type, scale: $scale, frequency: $frequency, octaves: $octaves, persistence: $persistence, lacunarity: $lacunarity, offsetX: $offsetX, offsetY: $offsetY, rotation: $rotation, invert: $invert, clampMin: $clampMin, clampMax: $clampMax, seed: $seed)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LayerNoiseParamsImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.scale, scale) || other.scale == scale) &&
            (identical(other.frequency, frequency) ||
                other.frequency == frequency) &&
            (identical(other.octaves, octaves) || other.octaves == octaves) &&
            (identical(other.persistence, persistence) ||
                other.persistence == persistence) &&
            (identical(other.lacunarity, lacunarity) ||
                other.lacunarity == lacunarity) &&
            (identical(other.offsetX, offsetX) || other.offsetX == offsetX) &&
            (identical(other.offsetY, offsetY) || other.offsetY == offsetY) &&
            (identical(other.rotation, rotation) ||
                other.rotation == rotation) &&
            (identical(other.invert, invert) || other.invert == invert) &&
            (identical(other.clampMin, clampMin) ||
                other.clampMin == clampMin) &&
            (identical(other.clampMax, clampMax) ||
                other.clampMax == clampMax) &&
            (identical(other.seed, seed) || other.seed == seed));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      type,
      scale,
      frequency,
      octaves,
      persistence,
      lacunarity,
      offsetX,
      offsetY,
      rotation,
      invert,
      clampMin,
      clampMax,
      seed);

  /// Create a copy of LayerNoiseParams
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LayerNoiseParamsImplCopyWith<_$LayerNoiseParamsImpl> get copyWith =>
      __$$LayerNoiseParamsImplCopyWithImpl<_$LayerNoiseParamsImpl>(
          this, _$identity);
}

abstract class _LayerNoiseParams implements LayerNoiseParams {
  const factory _LayerNoiseParams(
      {final LayerNoiseType type,
      final double scale,
      final double frequency,
      final int octaves,
      final double persistence,
      final double lacunarity,
      final double offsetX,
      final double offsetY,
      final double rotation,
      final bool invert,
      final double clampMin,
      final double clampMax,
      final int seed}) = _$LayerNoiseParamsImpl;

  @override
  LayerNoiseType get type;
  @override
  double get scale;
  @override
  double get frequency;
  @override
  int get octaves;
  @override
  double get persistence;
  @override
  double get lacunarity;
  @override
  double get offsetX;
  @override
  double get offsetY;
  @override
  double get rotation;
  @override
  bool get invert;
  @override
  double get clampMin;
  @override
  double get clampMax;
  @override
  int get seed;

  /// Create a copy of LayerNoiseParams
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LayerNoiseParamsImplCopyWith<_$LayerNoiseParamsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Layer {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get visible => throw _privateConstructorUsedError;
  LayerBlendMode get blendMode => throw _privateConstructorUsedError;
  double get opacity => throw _privateConstructorUsedError;
  LayerNoiseParams get noise => throw _privateConstructorUsedError;
  ui.Image? get cachedData => throw _privateConstructorUsedError;

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LayerCopyWith<Layer> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LayerCopyWith<$Res> {
  factory $LayerCopyWith(Layer value, $Res Function(Layer) then) =
      _$LayerCopyWithImpl<$Res, Layer>;
  @useResult
  $Res call(
      {String id,
      String name,
      bool visible,
      LayerBlendMode blendMode,
      double opacity,
      LayerNoiseParams noise,
      ui.Image? cachedData});

  $LayerNoiseParamsCopyWith<$Res> get noise;
}

/// @nodoc
class _$LayerCopyWithImpl<$Res, $Val extends Layer>
    implements $LayerCopyWith<$Res> {
  _$LayerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? visible = null,
    Object? blendMode = null,
    Object? opacity = null,
    Object? noise = null,
    Object? cachedData = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      blendMode: null == blendMode
          ? _value.blendMode
          : blendMode // ignore: cast_nullable_to_non_nullable
              as LayerBlendMode,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      noise: null == noise
          ? _value.noise
          : noise // ignore: cast_nullable_to_non_nullable
              as LayerNoiseParams,
      cachedData: freezed == cachedData
          ? _value.cachedData
          : cachedData // ignore: cast_nullable_to_non_nullable
              as ui.Image?,
    ) as $Val);
  }

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LayerNoiseParamsCopyWith<$Res> get noise {
    return $LayerNoiseParamsCopyWith<$Res>(_value.noise, (value) {
      return _then(_value.copyWith(noise: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LayerImplCopyWith<$Res> implements $LayerCopyWith<$Res> {
  factory _$$LayerImplCopyWith(
          _$LayerImpl value, $Res Function(_$LayerImpl) then) =
      __$$LayerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      bool visible,
      LayerBlendMode blendMode,
      double opacity,
      LayerNoiseParams noise,
      ui.Image? cachedData});

  @override
  $LayerNoiseParamsCopyWith<$Res> get noise;
}

/// @nodoc
class __$$LayerImplCopyWithImpl<$Res>
    extends _$LayerCopyWithImpl<$Res, _$LayerImpl>
    implements _$$LayerImplCopyWith<$Res> {
  __$$LayerImplCopyWithImpl(
      _$LayerImpl _value, $Res Function(_$LayerImpl) _then)
      : super(_value, _then);

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? visible = null,
    Object? blendMode = null,
    Object? opacity = null,
    Object? noise = null,
    Object? cachedData = freezed,
  }) {
    return _then(_$LayerImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      blendMode: null == blendMode
          ? _value.blendMode
          : blendMode // ignore: cast_nullable_to_non_nullable
              as LayerBlendMode,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      noise: null == noise
          ? _value.noise
          : noise // ignore: cast_nullable_to_non_nullable
              as LayerNoiseParams,
      cachedData: freezed == cachedData
          ? _value.cachedData
          : cachedData // ignore: cast_nullable_to_non_nullable
              as ui.Image?,
    ));
  }
}

/// @nodoc

class _$LayerImpl implements _Layer {
  const _$LayerImpl(
      {required this.id,
      this.name = 'New Layer',
      this.visible = true,
      this.blendMode = LayerBlendMode.add,
      this.opacity = 1.0,
      this.noise = const LayerNoiseParams(),
      this.cachedData = null});

  @override
  final String id;
  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final bool visible;
  @override
  @JsonKey()
  final LayerBlendMode blendMode;
  @override
  @JsonKey()
  final double opacity;
  @override
  @JsonKey()
  final LayerNoiseParams noise;
  @override
  @JsonKey()
  final ui.Image? cachedData;

  @override
  String toString() {
    return 'Layer(id: $id, name: $name, visible: $visible, blendMode: $blendMode, opacity: $opacity, noise: $noise, cachedData: $cachedData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LayerImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.blendMode, blendMode) ||
                other.blendMode == blendMode) &&
            (identical(other.opacity, opacity) || other.opacity == opacity) &&
            (identical(other.noise, noise) || other.noise == noise) &&
            (identical(other.cachedData, cachedData) ||
                other.cachedData == cachedData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, id, name, visible, blendMode, opacity, noise, cachedData);

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LayerImplCopyWith<_$LayerImpl> get copyWith =>
      __$$LayerImplCopyWithImpl<_$LayerImpl>(this, _$identity);
}

abstract class _Layer implements Layer {
  const factory _Layer(
      {required final String id,
      final String name,
      final bool visible,
      final LayerBlendMode blendMode,
      final double opacity,
      final LayerNoiseParams noise,
      final ui.Image? cachedData}) = _$LayerImpl;

  @override
  String get id;
  @override
  String get name;
  @override
  bool get visible;
  @override
  LayerBlendMode get blendMode;
  @override
  double get opacity;
  @override
  LayerNoiseParams get noise;
  @override
  ui.Image? get cachedData;

  /// Create a copy of Layer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LayerImplCopyWith<_$LayerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
